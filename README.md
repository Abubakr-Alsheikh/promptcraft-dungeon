# PromptCraft: Dungeon Delver

_An AI-powered, full-stack text adventure game where every journey is unique._

![Next.js](https://img.shields.io/badge/Next.js-14.x-black?style=for-the-badge&logo=next.js&logoColor=white)
![React](https://img.shields.io/badge/React-19-blue?style=for-the-badge&logo=react&logoColor=white)
![Flask](https://img.shields.io/badge/Flask-3.x-black?style=for-the-badge&logo=flask&logoColor=white)
![Python](https://img.shields.io/badge/Python-3.11+-blue?style=for-the-badge&logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-5.x-blue?style=for-the-badge&logo=typescript&logoColor=white)
![SQLAlchemy](https://img.shields.io/badge/SQLAlchemy-2.x-red?style=for-the-badge&logo=sqlalchemy&logoColor=white)

---

## üìñ About The Project

**PromptCraft: Dungeon Delver** is a modern take on the classic text-based RPG. Instead of a pre-written story, it leverages the power of Large Language Models (LLMs) to dynamically generate every aspect of the adventure in real-time. From evocative room descriptions and unexpected events to the consequences of your actions, the world is crafted by AI, for you.

This project is a full-stack application built with a sophisticated architecture, featuring a reactive **Next.js/TypeScript** frontend and a robust **Python/Flask** backend. The core innovation lies in the backend's AI orchestration service, which uses advanced prompt engineering and Pydantic schemas to ensure the AI's creative output is returned as structured, reliable JSON. This allows for deterministic game state updates, creating a seamless and immersive experience.

[‚û°Ô∏è **Live Demo**](https://promptcraft-dungeon.vercel.app/)

---

## ‚ú® Key Features

*   **Dynamic World Generation:** Every room, event, and narrative description is generated by an AI, ensuring no two adventures are the same.
*   **Dual AI Provider Support:** Seamlessly switch between a local **Ollama** instance for privacy and speed, or a powerful cloud model like **Google Gemini** for enhanced creativity. Includes intelligent fallback logic.
*   **Structured AI Responses:** Utilizes carefully engineered system prompts and Pydantic validation to force the LLM into providing structured JSON output, enabling reliable parsing of game events, inventory changes, and stat updates.
*   **Reactive & Modern UI:** A fluid user interface built with Next.js, TypeScript, and Chakra UI, featuring animated text rendering (Framer Motion) and a custom sound manager (Howler.js).
*   **Comprehensive State Management:** Global state is managed with Zustand, organized into modular slices for scalability and maintainability (game state, UI, settings, etc.).
*   **Robust Backend Architecture:** The Flask backend is built using the App Factory pattern, Blueprints for route organization, SQLAlchemy for the ORM, and Alembic for database migrations.
*   **Full Game Loop:** Features include a complete inventory system, player stats, user-configurable settings (audio, text animation speed), and persistent game progress.

---

## üõ†Ô∏è Tech Stack

### Frontend
*   **Framework:** [Next.js](https://nextjs.org/) (App Router)
*   **Language:** [TypeScript](https://www.typescriptlang.org/)
*   **UI Library:** [Chakra UI](https://chakra-ui.com/)
*   **State Management:** [Zustand](https://github.com/pmndrs/zustand)
*   **Animation:** [Framer Motion](https://www.framer.com/motion/)
*   **Audio:** [Howler.js](https://howlerjs.com/)
*   **API Communication:** [Axios](https://axios-http.com/) / `fetch`

### Backend
*   **Framework:** [Flask](https://flask.palletsprojects.com/)
*   **Language:** [Python](https://www.python.org/)
*   **ORM:** [SQLAlchemy](https://www.sqlalchemy.org/)
*   **Database Migrations:** [Alembic](https://alembic.sqlalchemy.org/) (via Flask-Migrate)
*   **API Validation:** [Pydantic](https://docs.pydantic.dev/)
*   **Web Server:** Gunicorn (for production), Werkzeug (for development)

### AI & Services
*   **AI Models:** [Ollama](https://ollama.com/) (Local), [Google Gemini](https://ai.google.dev/) (Cloud)
*   **Database:** PostgreSQL (production recommended), SQLite (development)

---

## ‚öôÔ∏è Getting Started

Follow these instructions to get a local copy of the project up and running for development and testing.

### Prerequisites

*   **Node.js** (v18 or later) & **npm**
*   **Python** (v3.10 or later) & **pip**
*   (Optional but Recommended) An AI provider:
    *   [Ollama](https://ollama.com/) for local inference.
    *   A Google AI API Key for [Gemini](https://ai.google.dev/).

### 1. Backend Setup

First, let's get the Flask server running.

1.  **Clone the repository:**
    ```sh
    git clone https://github.com/Abubakr-Alsheikh/promptcraft-dungeon.git
    cd promptcraft-dungeon
    ```

2.  **Navigate to the backend directory:**
    ```sh
    cd backend
    ```

3.  **Create and activate a Python virtual environment:**
    ```sh
    # For Windows
    python -m venv venv
    .\venv\Scripts\activate

    # For macOS/Linux
    python3 -m venv venv
    source venv/bin/activate
    ```

4.  **Install Python dependencies:**
    ```sh
    pip install -r requirements.txt
    ```

5.  **Configure environment variables:**
    *   Copy the example `.env` file.
      ```sh
      cp .example.env .env
      ```
    *   Open the `.env` file and configure it. See the **AI Configuration** section below for details on `USE_LOCAL`, `OLLAMA_URL`, and `GEMINI_API_KEY`.

6.  **Initialize and upgrade the database:**
    *   (This command needs to be run from the `backend` directory)
    ```sh
    # Make sure your virtual environment is active
    flask db upgrade
    ```
    This will create the `instance/app.db` SQLite database and apply the necessary schemas.

7.  **Run the backend server:**
    ```sh
    python run.py
    ```
    The backend API should now be running on `http://localhost:5001`.

### 2. Frontend Setup

Now, set up the Next.js frontend in a separate terminal.

1.  **Navigate to the project root directory** (if you are in the `backend` folder, go back one level).
    ```sh
    cd ..
    ```

2.  **Install Node.js dependencies:**
    ```sh
    npm install
    ```

3.  **Run the frontend development server:**
    ```sh
    npm run dev
    ```

4.  **Open your browser** and navigate to `http://localhost:3000`. You should see the game's home screen!

---

## ü§ñ AI Configuration

The backend is configured to use either a local Ollama instance or the cloud-based Google Gemini API. You can switch between them using the `.env` file in the `backend` directory.

*   **To use local Ollama (Recommended for development):**
    1.  Install and run [Ollama](https://ollama.com/).
    2.  Pull a model suitable for the game. `deepseek-coder:1.3b` or `phi3` are good, lightweight starting points.
        ```sh
        ollama pull deepseek-coder:1.3b
        ```
    3.  In your `backend/.env` file, set:
        ```env
        USE_LOCAL=true
        OLLAMA_MODEL=deepseek-coder:1.3b # Or whichever model you pulled
        OLLAMA_URL=http://localhost:11434
        # You can leave GEMINI_API_KEY blank
        GEMINI_API_KEY=
        ```

*   **To use Google Gemini:**
    1.  Get an API key from [Google AI Studio](https://makersuite.google.com/app/apikey).
    2.  In your `backend/.env` file, set:
        ```env
        USE_LOCAL=false
        GEMINI_API_KEY=YOUR_GOOGLE_API_KEY_HERE
        ```

---

## üöÄ Future Improvements

- [ ] Implement a more complex combat system with varied enemy types.
- [ ] Introduce a quest and NPC dialogue system.
- [ ] Add support for more AI models and providers (e.g., Anthropic Claude).
- [ ] Use WebSockets for more interactive, real-time events.
- [ ] Create a "Game Master Mode" where a user can influence the AI's narration.
